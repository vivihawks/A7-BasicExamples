
import {fromEvent as observableFromEvent,  Observable } from 'rxjs';

import {debounceTime} from 'rxjs/operators';
import { Component , ElementRef, ChangeDetectorRef, OnInit, ViewEncapsulation} from '@angular/core';
import * as Rx from 'rxjs';

import { from, of } from "rxjs";
import { map, catchError,delay, timeout } from 'rxjs/operators';


@Component({
  selector: 'app',
  template: `
        <div layout-margin layout layout-align="center">
          <h1>Angular Observables</h1>
        </div>

    <div class="rendered" flex layout>
    
    <h4 >Ex 1 : Basic Observable</h4>
    <h6 style="margin-bottom: 0">VALUES:</h6>
      <div *ngFor="let value of values">{{ value }}</div>

      <h6 style="margin-bottom: 0">ERRORs:</h6>
      <div>Errors: {{anyErrors}}</div>

      <h6 style="margin-bottom: 0">FINISHED:</h6>
      <div>Finished: {{ finished }}</div>

      <button style="margin-top: 2rem;" (click)="init()">Init</button>
    
    <h4 >Ex 2 : Observable Map</h4>
      <ul>
        
        <li *ngFor="let item of items">
          <div >
            <h3>{{item.price}}</h3>
          </div>
        </li>
      </ul>
    </div>
<br><br><br> <h4>Ex 3 : Error Handling in Observables </h4>
          <div >
            <h3>NEXT: {{nextMessage}}</h3>
            <h3>ERROR: {{errorMessage}}</h3>
            <h3>COMPLETED: {{completedMessage}}</h3>
          </div>

<br><br><br> <h4>Ex 4 : Observable from Events</h4>
<ul>
        <li  *ngFor="let coordinate of coordinates">
          <div >
            <p>x: {{coordinate.x}} y: {{coordinate.y}}</p>
          </div>
        </li>
</ul>
  <br><br><br> <h4>Ex 5 : Observables Combined</h4>
  Refer Console Log
  <br><br><br> <h4>Ex 6 : Observables Combined 2</h4>
  Refer Console Log
  <obs-combined></obs-combined> 
  
   `,
   styles:[`h4{font-weight:bold; color: darkgreen; text-decoration: underline;}`]
   
})

export class App implements OnInit{
  //For Example 1
   data: Observable<number>;
   values: Array<number> = [];
   anyErrors: boolean;
   finished: boolean;
  
  //For Example 2
  items: {}[] = [];

  //For Example 3 
  nextMessage: string;
  errorMessage: string;
  completedMessage: string;
  
  //For Example 4 
  coordinates: Array<{ x: number, y: number }> = [];
  
  
  init(){
    //Stream - is a sequence of values over time. Generated by observables, consumed by subscribers
    //Subscriptions listen to stream
    //Observables are  triggered by a  subscriber subscribing to them
    //Observables start separately as copies for each subscriber.
    //Example 1 : Basic Observable - This is a COLD Observable
     this.data = new Observable<number>((observer:any) => {

      //1. Server call - Authorize user
      //2. Server call - get roles
      //3. Server call - reconcile roles / groups
      //4. Get accessible resources for the current authorization
        setTimeout(
          () => {
              observer.next(42);
          }, 1000);

          setTimeout(() => {
              observer.next(43); 
          }, 2000);

          setTimeout(() => {
               observer.next(44);
              }, 3000);
              
          setTimeout(() => {
               observer.next(45);
              }, 4000);

          setTimeout(() => {
              //observer.error();
              observer.complete();
          }, 5000);
      })
    //  publish;

      let subscription = this.data.subscribe(
        // function(abc) { this.values.push(abc) },
        value => this.values.push(value),
         error => this.anyErrors = true,
         () => this.finished = true
     );
   
      let subscription2 = this.data.subscribe(
         //function(value){this.values.push(value)},
         value => this.values.unshift(333)
     );
   
  }
  
  constructor(
    private elementRef: ElementRef,
    private detectorRef: ChangeDetectorRef
  ) {
    
    //Example 2 : Observable Map
    //Observable
      from([{price: 1}, {price: 2}, {price: 3}, {price: 4}, {price: 5}]).pipe(
        map(item => {
            return {price:item.price*2};
            }
        )
      )
       
      //new Promise().then().then().then()

      .subscribe(item => this.items.unshift(item));
    
    //Example 3 : Observable Error Handling
    var source = //Rx.Observable
        of("42","43","45","Last Number").pipe(
            // This will complete in 5 seconds
            delay(5000)
            // We will override this to throw an error in 1 second
            ,timeout(1000)
            // Uncomment this to catch the error and continue the stream
            ,catchError(() => of('Recovering!'))
        );
 
     var subscription = source.subscribe(
        x => this.nextMessage = x, // onNext handler
        err => this.errorMessage = err, // onError handler
        () => this.completedMessage = 'Completed' // onComplete handler
      );
  }
    
  
//Example 4 : Mouse Event Observer. HOT Observable
    ngOnInit() {
    observableFromEvent<MouseEvent>(this.elementRef.nativeElement, 'mousemove').pipe(
        debounceTime(20)
        ,map(evt => { return {x: evt.clientX, y: evt.clientY}; })
   )
    .subscribe(
      coordinate => {
        this.coordinates.unshift(coordinate);
        //this.detectorRef.detectChanges();
      },
      err => console.log('Error:', err),
      () => console.log('Completed')
    );
  }
}
