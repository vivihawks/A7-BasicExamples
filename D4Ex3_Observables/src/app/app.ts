
import { fromEvent, fromEvent as observableFromEvent, interval, Observable } from 'rxjs';

import { bufferTime, debounceTime, distinctUntilChanged, filter, take, takeUntil, takeWhile, throttleTime } from 'rxjs/operators';
import { Component, ElementRef, ChangeDetectorRef, OnInit, ViewEncapsulation } from '@angular/core';
import * as Rx from 'rxjs';

import { from, of } from "rxjs";
import { map, catchError, delay, timeout } from 'rxjs/operators';


@Component({
  selector: 'app',
  template: `
        <div layout-margin layout layout-align="center">
          <h1>Angular Observables</h1>
        </div>

    <div class="rendered" flex layout>
    
    <h4 >Ex 1 : Basic Observable</h4>
    <h6 style="margin-bottom: 0">VALUES:</h6>
      <div *ngFor="let value of values">{{ value }}</div>

      <h6 style="margin-bottom: 0">ERRORs:</h6>
      <div>Errors: {{anyErrors}}</div>

      <h6 style="margin-bottom: 0">FINISHED:</h6>
      <div>Finished: {{ finished }}</div>

      <button style="margin-top: 2rem;" (click)="init()">Init</button>
    
    <h4 >Ex 2 : Observable Map</h4>
      <ul>
        
        <li *ngFor="let item of items">
          <div >
            <h3>{{item.price}}</h3>
          </div>
        </li>
      </ul>
    </div>
<br><br><br> <h4>Ex 3 : Error Handling in Observables </h4>
          <div >
            <h3>NEXT: {{nextMessage}}</h3>
            <h3>ERROR: {{errorMessage}}</h3>
            <h3>COMPLETED: {{completedMessage}}</h3>
          </div>

<br><br><br> <h4>Ex 4 : Observable from Events</h4>
<ul>
        <li  *ngFor="let coordinate of coordinates">
          <div >
            <p>x: {{coordinate.x}} y: {{coordinate.y}}</p>
          </div>
        </li>
</ul>
  <br><br><br> <h4>Ex 5 : Observables Combined</h4>
  Refer Console Log
  <br><br><br> <h4>Ex 6 : Observables Combined 2</h4>
  Refer Console Log
  <obs-combined></obs-combined> 
  
   `,
  styles: [`h4{font-weight:bold; color: darkgreen; text-decoration: underline;}`]

})

export class App implements OnInit {
  //For Example 1
  data!: Observable<number>;
  values: Array<number> = [];
  anyErrors!: boolean;
  finished!: boolean;

  //For Example 2
  items: any[] = [];

  //For Example 3 
  nextMessage!: string;
  errorMessage!: string;
  completedMessage!: string;

  //For Example 4 
  coordinates: Array<{ x: number, y: number }> = [];


  init() {
    //Stream - is a sequence of values over time. Generated by observables, consumed by subscribers
    //Subscriptions listen to stream
    //Observables are  triggered by a  subscriber subscribing to them
    //Observables start separately as copies for each subscriber.
    //Example 1 : Basic Observable - This is a COLD Observable
    this.data = new Observable<number>((observer: any) => {

      //1. Server call - Authorize user
      //2. Server call - get roles
      //3. Server call - reconcile roles / groups
      //4. Get accessible resources for the current authorization
      setTimeout(
        () => {
          observer.next(42);
        }, 1000);

      setTimeout(() => {
        observer.next(43);
      }, 2000);

      setTimeout(() => {
        observer.next(44);
      }, 3000);

      setTimeout(() => {
        observer.next(45);
      }, 4000);

      setTimeout(() => {
        observer.error();
        // observer.complete();
        observer.next(100);
      }, 5000);
    })
    // .publish();

    let subscription = this.data.subscribe({
      next: value => this.values.push(value),
      error: error => this.anyErrors = true,
      complete: () => this.finished = true
  });

    setTimeout(() => this.data.subscribe(
      value => this.values.unshift(value * 2)
    ), 2000);

  }

  constructor(
    private elementRef: ElementRef,
    private detectorRef: ChangeDetectorRef
  ) {

    //Example 2 : Observable Map
    //Observable
    from([{ price: 1 }, { price: 2 }, { price: 3 }, { price: 4 }, { price: 5 }])
      .pipe(
        map(item => {
          return { price: item.price * 2 };
        }
        )
      )

      //new Promise().then().then().then()

      .subscribe(item => this.items.unshift(item));

    //Example 3 : Observable Error Handling
    var source = //Rx.Observable
      of("42", "43", "45", "Last Number")
        .pipe(
          // This will complete in 5 seconds
          delay(3000)
          // We will override this to throw an error in 1 second
          , timeout(1000)
          // Uncomment this to catch the error and continue the stream
          , catchError(() => of('Recovering!'))
        );

    var subscription = source.subscribe({
      next: x => this.nextMessage = x, // onNext handler
      error: err => this.errorMessage = err, // onError handler
      complete: () => this.completedMessage = 'Completed' // onComplete handler
    });
  }


  //Example 4 : 
  ngOnInit() {

    //4a - Mouse Event Observer & Debounce. HOT Observable
    console.log('Example 4a. Mouse Event Observer')
    observableFromEvent<MouseEvent>(this.elementRef.nativeElement, 'mousemove').pipe(
      debounceTime(200)
      , map(evt => { return { x: evt.clientX, y: evt.clientY }; })
    )
      .subscribe({
        next: coordinate => {
          this.coordinates.unshift(coordinate);
          this.detectorRef.detectChanges();
        },
        error: err => console.log('4a. Error:', err),
        complete: () => console.log('4a. Completed')
      });

    //4b - Filter
    console.log('Example 4b. Filter')

    const predicate = (n: number) => n <= 2;
    //(n: number) => n <= 2; 
    /*
     function(n:number){
       return n<=2;
     }
    */


    of(1, 2, 3, 4, 5)
      .pipe(
        filter(predicate)
      )
     .subscribe(console.log);
    // will log 1,2


    //4c - Distinct Until Changed
    console.log('Example 4b. Distinct Until Changed')
    const textChanges$ = of(1, 1, 1, 1, 2, 3, 3, 3, 4, 5);
    textChanges$
      .pipe(
        distinctUntilChanged()
      )
      .subscribe(console.log);

    //4d - Debounce Time(Take the latest from the given time window)
    console.log('Example 4d. Debounce Time')
    interval(100)
      .pipe(
        take(1000),//take x entries
        // filter(Boolean),
        // distinctUntilChanged(),
        debounceTime(200)//take latest in every x ms
      )
     //.subscribe(x => console.log(`Example 4d - ${x}`));
    //console.clear();

    //4e - Throttle Time(Take the first from the given time window)
    console.log('Example 4e. Throttle Time')
    interval(100)
      .pipe(
        //alternates for unsubscribe();
        take(100),
        filter(Boolean),
        distinctUntilChanged(),
        throttleTime(1000)
      )
    //  .subscribe(console.log);

    //4f - TakeUntil and TakeWhile alternates for unsubscribe
    console.log('Example 4f. TakeUntil and TakeWhile - alternates for unsubscribe')
    interval(100)
      .pipe(
        //Comment one of the below and inspect the console
        takeUntil(of(0).pipe(delay(2000))),
        // takeWhile(i=> i<25),
        map(n => "Example 4f ->" + n),

      )
    //    .subscribe(console.log);

    //4g - BufferTime - Batch entries before streaming
    console.log('Example 4g. BufferTime - Batch entries before streaming')
    interval(500)
      .pipe(
        bufferTime(3000),
        // takeWhile(i=> i<25),
        map(n => "Example 4g ->" + n),

      )
     .subscribe(console.log);

  }
}
